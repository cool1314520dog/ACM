/***********************************************************************
输入正整数n,把整数1,2,3……,n组成一个环,使得相邻两个整数之和均为素数,输出时从整数1开始逆时针排序.同一个环应恰好输出一次.n<==16
样例输入：
6
样例输出:
1 4 3 2 5 66
1 6 5 2 3 4

分析:
1、每个环都从1开始，先将数组a[0]赋值1.
2、每选定前一个素数，后一个位置就少一个可选择项，由此可用一个数组bUsed[]来标记状态.
3、前一个后一个选定值总和前一个选定值关联，由此可用回溯法(深度优先遍历的方式遍历解答树)。
************************************************************************/

#include <iostream>
#include <math.h>
#include<cstring>
using namespace std;
int n=0;//输入n<=16
int a[20];
bool bUsed[20];//对应数组a[20],判断对应节点在当前求得素数环中(解答树)是否有它

/*判断是素数*/
bool isp(int n){
	if(n<3)
		return false ;
	int len=(int)sqrt(n+0.0);
	for (int i=2;i<=len;i++){
		if(n%i==0)
			return false ;
	}
	return true;
}

/*递归输出所有素数环*/
void AA(int cur){
	//在最后一层执行,输出当前求得解答串
	if(cur==n&&isp(a[0]+a[n-1])){
		for (int i=0;i<n;i++)
			cout<<a[i]<<' ';
		cout<<endl;
		return ;
	}
	//前n-1层执行,递归选定每一层的整数,使其与前一层的整数之和为素数
	else for (int i=2;i<= n;i++){
		if(!bUsed[i]&&isp(i+a[cur-1])){	//当前值i没被使用,且与前一个选定值之和为素数
			a[cur]=i;//选i为当前项值
			bUsed[i]=true;//状态从没被使用改为被使用
			AA(cur+1);//进入下一层,若cur+1<n则求下一个有效值,否则执行输出语句
			//递归后面的语句在从n-1层到第1层回调时执行
			bUsed[i]=false;//状态还原,使重新求下一个有效串时不被干扰
		}
	}
}

int main(){
	for (int i=0;i<20;i++)
		a[i]=i+1;//初始化一个数组1,2,3,4...
	memset(bUsed,0,sizeof(bUsed));//全部初始化为false表示均没被使用
	while (cin>>n,n){
		AA(1);//回溯法遍历解答树,输出所有素数环
	}
}
